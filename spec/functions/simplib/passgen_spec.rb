#!/usr/bin/env ruby -S rspec
require 'spec_helper'
require 'base64'

def locked_operation(lockfile, &block)
  locker_thread = nil   # thread that will lock the file
  mutex = Mutex.new
  locked = ConditionVariable.new
  begin
    locker_thread = Thread.new do
      puts "     >> Locking lock file #{lockfile}"
      file = File.open(lockfile, 'w')
      file.flock(File::LOCK_EX)

      # signal the lock has taken place
      mutex.synchronize { locked.signal }

      # pause the thread until we are done our access attempt
      Thread.stop
      file.close
      puts '     >> Lock released with close'
    end


    # wait for the thread to signal the lock has taken place
    mutex.synchronize { locked.wait(mutex) }

    # exercise the accessor
    block.call

  ensure
    if locker_thread
      # wait until thread has paused
      sleep 0.5 while locker_thread.status != 'sleep'

      # resume and then wait until thread completed
      locker_thread.run
      locker_thread.join
    end
  end

end

def parse_modular_crypt(input)
  retval = nil
  support_params = {
    'bcrypt' => {},
    'scrypt' => {},
    'argon2' => {},
  }
  algorithm_lookup = {
    '1' => 'md5',
    '2' => 'bcrypt',
    '3' => 'lmhash',
    '5' => 'sha256',
    '6' => 'sha512',
    'scrypt' => 'scrypt',
    'argon2' => 'argon2',
  }
  begin
    grab_params = false
    grab_salt = false
    grab_hash = false
    hash = {}
    split_input = input.split("$");
    index = 0;
    if (split_input.size > 2)
      split_input.each do |token|
        if (index == 1)
          hash['algorithm_code'] = token;
          if (algorithm_lookup.key?(token))
            hash['algorithm'] = algorithm_lookup[token];
            if (support_params.key?(hash['algorithm']))
              grab_params = true
            end
            grab_salt = true
            grab_hash = true
          end
        else
          if grab_params == true
            hash['params'] = token
            grab_params = false
          elsif grab_salt == true
            hash['salt'] = token
            grab_salt = false
          elsif grab_hash == true
            padding = token.length % 4
            hash['hash_orig'] = token
            hash['hash_base64'] = token.gsub(/\./, '+').rjust(padding + token.length, '=')
            hash['hash_decoded'] = Base64.decode64(hash['hash_base64']).bytes.to_a
            hash['hash_bitlength'] = hash['hash_decoded'].size * 8;
            grab_hash = false
          end
        end
        index += 1;
      end
      retval = hash
    end
  rescue Exception => e
    puts e
    retval = nil
  end
  return retval
end

describe 'simplib::passgen' do
  on_supported_os.each do |os, os_facts|
    context "on #{os}" do
      let(:facts){ os_facts }

      let(:default_chars) do
        (("a".."z").to_a + ("A".."Z").to_a + ("0".."9").to_a).map do|x|
          x = Regexp.escape(x)
        end
      end

      let(:safe_special_chars) do
        ['@','%','-','_','+','=','~'].map do |x|
          x = Regexp.escape(x)
        end
      end

      let(:unsafe_special_chars) do
        (((' '..'/').to_a + ('['..'`').to_a + ('{'..'~').to_a)).map do |x|
          x = Regexp.escape(x)
        end - safe_special_chars
      end
      let(:base64_regex) do
        '^[a-zA-Z0-9+/=]+$'
      end

      after(:each) do
        # This is required for GitLab, because the spec tests are run by a
        # privileged user who ends up creating a global file store in
        # /var/simp/libkv/file/auto_default, instead of a set of per-test,
        # temporary file stores, each within its test-specific Puppet
        # environment.
        #
        # If we wanted to be truly safe from privileged user issues, we would
        # either configure libkv to use the file plugin with an appropriate
        # per-test path, or, convert all the unit test to use rspec-mocks
        # instead of mocha and then use an appropriate pair of
        # `allow(FileUtils).to receive(:mkdir_p).with...` that fail the global
        # file store directory creation but allow other directory creations.
        # (See spec tests in pupmod-simp-libkv).
        #
        call_function('libkv::deletetree', 'gen_passwd')
      end

      # These tests check the actual password generated by passgen.
      # Ideally, the code that converts the password into the modular
      # crypt format would be moved to its own function.
      # But that's outside scope for now.

      context 'basic password generation' do
        it 'should run successfully with default arguments' do
          result = subject.execute('spectest')
          expect(result.length).to eq 32
          expect(result).to match(/^(#{default_chars.join('|')})+$/)

          # retrieve what has been stored by libkv and validate
          stored_info = call_function('libkv::get', 'gen_passwd/spectest')
          expect(stored_info['value']['password']).to eq result
          salt = stored_info['value']['salt']
          expect(salt.length).to eq 16
          expect(salt).to match(/^(#{default_chars.join('|')})+$/)
          meta = { 'complexity' => 0, 'complex_only' => false }
          expect(stored_info['metadata']).to eq(meta)
        end

        it 'should return a password that is 32 alphanumeric characters long by default' do
          result = subject.execute('spectest')
          expect(result.length).to eql(32)
          expect(result).to match(/^(#{default_chars.join('|')})+$/)
        end

        it 'should work with a String length' do
          result = subject.execute('spectest', {'length' => '16'})
          expect(result.length).to eql(16)
          expect(result).to match(/^(#{default_chars.join('|')})+$/)
        end

        it 'should return a password that is 8 alphanumeric characters long if length is 8' do
          result = subject.execute('spectest', {'length' => 8})
          expect(result.length).to eql(8)
          expect(result).to match(/^(#{default_chars.join('|')})+$/)
        end

        it 'should return a password that is 8 alphanumeric characters long if length is < 8' do
          result = subject.execute('spectest', {'length' => 4})
          expect(result.length).to eql(8)
          expect(result).to match(/^(#{default_chars.join('|')})+$/)
        end

        it 'should return a password that contains "safe" special characters if complexity is 1' do
          result = subject.execute('spectest', {'complexity' => 1})
          expect(result.length).to eql(32)
          expect(result).to match(/(#{default_chars.join('|')})/)
          expect(result).to match(/(#{(safe_special_chars).join('|')})/)
          expect(result).not_to match(/(#{(unsafe_special_chars).join('|')})/)

          # retrieve what has been stored by libkv and validate metadata
          stored_info = call_function('libkv::get', 'gen_passwd/spectest')
          meta = { 'complexity' => 1, 'complex_only' => false }
          expect(stored_info['metadata']).to eq(meta)
        end

        it 'should return a password that only contains "safe" special characters if complexity is 1 and complex_only is true' do
          result = subject.execute('spectest', {'complexity' => 1, 'complex_only' => true})
          expect(result.length).to eql(32)
          expect(result).not_to match(/(#{default_chars.join('|')})/)
          expect(result).to match(/(#{(safe_special_chars).join('|')})/)
          expect(result).not_to match(/(#{(unsafe_special_chars).join('|')})/)

          # retrieve what has been stored by libkv and validate metadata
          stored_info = call_function('libkv::get', 'gen_passwd/spectest')
          meta = { 'complexity' => 1, 'complex_only' => true }
          expect(stored_info['metadata']).to eq(meta)
        end

        it 'should work with a String complexity' do
          result = subject.execute('spectest', {'complexity' => '1'})
          expect(result.length).to eql(32)
          expect(result).to match(/(#{default_chars.join('|')})/)
          expect(result).to match(/(#{(safe_special_chars).join('|')})/)
          expect(result).not_to match(/(#{(unsafe_special_chars).join('|')})/)

          # retrieve what has been stored by libkv and validate metadata
          stored_info = call_function('libkv::get', 'gen_passwd/spectest')
          meta = { 'complexity' => 1, 'complex_only' => false }
          expect(stored_info['metadata']).to eq(meta)
        end

        it 'should return a password that contains all special characters if complexity is 2' do
          result = subject.execute('spectest', {'complexity' => 2})
          expect(result.length).to eql(32)
          expect(result).to match(/(#{default_chars.join('|')})/)
          expect(result).to match(/(#{(unsafe_special_chars).join('|')})/)

          # retrieve what has been stored by libkv and validate metadata
          stored_info = call_function('libkv::get', 'gen_passwd/spectest')
          meta = { 'complexity' => 2, 'complex_only' => false }
          expect(stored_info['metadata']).to eq(meta)
        end

        it 'should return a password that only contains all special characters if complexity is 2 and complex_only is true' do
          result = subject.execute('spectest', {'complexity' => 2, 'complex_only' => true})
          expect(result.length).to eql(32)
          expect(result).to_not match(/(#{default_chars.join('|')})/)
          expect(result).to match(/(#{(unsafe_special_chars).join('|')})/)

          # retrieve what has been stored by libkv and validate metadata
          stored_info = call_function('libkv::get', 'gen_passwd/spectest')
          meta = { 'complexity' => 2, 'complex_only' => true }
          expect(stored_info['metadata']).to eq(meta)
        end
      end

      context 'password generation with history' do
        it 'should return the next to last created password if "last" is true' do
          first_result = subject.execute('spectest', {'length' => 32})
          # changing password length forces a new password to be generated
          second_result = subject.execute('spectest', {'length' => 33})
          third_result = subject.execute('spectest', {'length' => 34})
          expect(subject.execute('spectest', {'last' => true})).to eql(second_result)
        end

        it 'should return the current password if "last" is true but there is no previous password' do
          result = subject.execute('spectest', {'length' => 32})
          expect(subject.execute('spectest', {'last' => true})).to eql(result)
        end

        it 'should return current password if no password options are specified' do
          # intentionally pick a password with a length different than default length
          result = subject.execute('spectest', {'length' => 64})
          expect(subject.execute('spectest')).to eql(result)
        end

        it 'should return a new password if "last" is true but there is no current or previous password' do
          result = subject.execute('spectest', {'last' => true})
          expect(result.length).to eql(32)
        end

      end

      context 'password encryption ' do
        # These tests check the resulting modular crypt formatted hash.
        {
          'md5' => {
            "code" => '1',
            "bits" => 128,
            "end_hash" => '$1$badsalt$lpOt58v4EmRjaID6kGO4j.'
          },
          'sha256' => {
            "code" => '5',
            "bits" => 256,
            "end_hash" => '$5$badsalt$FZYRq7gz.KjbTsd1uzm.lhPBvy9LAefLwvRn2PVVd37'
          },
          'sha512' => {
            "code" => '6',
            "bits" => 512,
            "end_hash" => '$6$badsalt$hk7dh/Mz.oPuPZgDkPrNU/WSQOOq6T8PA8FO4mmLkfGdgvyEvqd8HyD5UeD2aYysmczplpo5qkU8RYjX1R6LS0'
          }
        }.each do |hash_selection, object|
          context "when hash == #{hash_selection}" do

            let(:shared_options) do
              {
                'hash' => hash_selection,
                'complexity' => 2
              }
            end

            if File.exist?('/proc/sys/crypto/fips_enabled') &&
                File.open('/proc/sys/crypto/fips_enabled', &:readline)[0].chr == '1' &&
                hash_selection == 'md5'
              puts 'Skipping md5, as not available on this FIPS-compliant server'
            else
              it 'should parse as modular crypt' do
                result = subject.execute('spectest', shared_options);
                expect(parse_modular_crypt(result)).to_not eql(nil)
              end

              it "should use #{object['code']} as the algorithm code" do
                value = parse_modular_crypt(subject.execute('spectest', shared_options));
                expect(value['algorithm_code']).to eql(object['code'])
              end

              it 'should contain a salt of complexity 0' do
                value = parse_modular_crypt(subject.execute('spectest', shared_options));
                expect(value['salt']).to match(/^(#{default_chars.join('|')})+$/)
              end

              it 'should contain a base64 hash' do
                value = parse_modular_crypt(subject.execute('spectest', shared_options));
                expect(value['hash_base64']).to match(/#{base64_regex}/)
              end

              it "should contain a valid #{hash_selection} hash after decoding" do
                result = subject.execute('spectest', shared_options);
                value = parse_modular_crypt(result);
                expect(value['hash_bitlength']).to eql(object['bits'])
              end
            end
          end
        end
      end

      context 'password migration' do
        # DEBUG NOTES:
        #   Puppet[:vardir] is dynamically created as a tmpdir by the test
        #   framework, when the subject is first created. So if you want
        #   to know what vardir is so you can create/modify files in
        #   that directory as part of the test setup, in the 'it' block,
        #   first create the subject yourself and then retrieve the
        #   vardir value as shown below:
        #
        # it 'does something' do
        #   subject()  # vardir created as a tmpdir for this example block
        #   vardir = Puppet[:vardir]
        #
        #   <pre-seed file content here>
        #
        #   is_expected.to run.with_params('spectest')  # run the function
        #
        # end
        let(:key) { 'user1' }
        let(:password) { 'user1 password' }
        let(:salt) { 'user1 salt'}

        it 'should do nothing to old keydir when it has no files for the key' do
          # populate old keydir with a password file for a different key
          subject()
          vardir = Puppet[:vardir]
          old_keydir =  File.join(vardir, 'simp', 'environments', 'rp_env',
            'simp_autofiles', 'gen_passwd')

          FileUtils.mkdir_p(old_keydir)
          otheruser_passwd_file = File.join(old_keydir, 'other user')
          File.open(otheruser_passwd_file, 'w') { |file| file.puts('otheruser password') }

          result = subject.execute(key)
          expect(result.length).to eq 32

          expect( File.exist?(otheruser_passwd_file) ).to be true
          archive_dir =  File.join(vardir, 'simp', 'environments', 'rp_env',
            'simp_autofiles', '.gen_passwd')
          expect( Dir.exist?(archive_dir) ).to be false
        end

        it 'should migrate current password and salt' do
          # populate old keydir with current password and salt files for the key
          subject()
          vardir = Puppet[:vardir]
          old_keydir =  File.join(vardir, 'simp', 'environments', 'rp_env',
            'simp_autofiles', 'gen_passwd')
          FileUtils.mkdir_p(old_keydir)
          password_file = File.join(old_keydir, key)
          File.open(password_file, 'w') { |file| file.puts(password) }
          salt_file =  "#{password_file}.salt"
          File.open(salt_file, 'w') { |file| file.puts(salt) }

          result = subject.execute(key)
          expect(result).to eq password

          # retrieve what has been stored by libkv and validate
          stored_info = call_function('libkv::get', "gen_passwd/#{key}")
          expect(stored_info['value']['password']).to eq password
          expect(stored_info['value']['salt']).to eq salt

          expect( File.exist?(password_file) ).to be false
          expect( File.exist?(salt_file) ).to be false

          archive_password_file = password_file.gsub('gen_passwd', '.gen_passwd')
          expect( File.exist?(archive_password_file) ).to be true
          expect( IO.read(archive_password_file).strip ).to eq password
          archive_salt_file = salt_file.gsub('gen_passwd', '.gen_passwd')
          expect( File.exist?(archive_salt_file) ).to be true
          expect( IO.read(archive_salt_file).strip ).to eq salt
        end

        it 'should migrate last password and salt' do
          # populate old keydir with last password and salt files for the key
          subject()
          vardir = Puppet[:vardir]
          old_keydir =  File.join(vardir, 'simp', 'environments', 'rp_env',
            'simp_autofiles', 'gen_passwd')
          FileUtils.mkdir_p(old_keydir)
          last_password_file = File.join(old_keydir, "#{key}.last")
          File.open(last_password_file, 'w') { |file| file.puts(password) }
          last_salt_file = File.join(old_keydir, "#{key}.salt.last")
          File.open(last_salt_file, 'w') { |file| file.puts(salt) }

          result = subject.execute(key, {'last' => true})
          expect(result).to eq password

          # retrieve what has been stored by libkv and validate
          stored_info = call_function('libkv::get', "gen_passwd/#{key}.last")
          expect(stored_info['value']['password']).to eq password
          expect(stored_info['value']['salt']).to eq salt

          expect( File.exist?(last_password_file) ).to be false
          expect( File.exist?(last_salt_file) ).to be false

          archive_password_file = last_password_file.gsub('gen_passwd', '.gen_passwd')
          expect( File.exist?(archive_password_file) ).to be true
          archive_salt_file = last_salt_file.gsub('gen_passwd', '.gen_passwd')
          expect( File.exist?(archive_salt_file) ).to be true
        end

        it 'should generate salt for current password when existing salt is empty' do
          # populate old keydir with current password and salt files for the key
          subject()
          vardir = Puppet[:vardir]
          old_keydir =  File.join(vardir, 'simp', 'environments', 'rp_env',
            'simp_autofiles', 'gen_passwd')
          FileUtils.mkdir_p(old_keydir)
          password_file = File.join(old_keydir, key)
          File.open(password_file, 'w') { |file| file.puts(password) }
          salt_file =  "#{password_file}.salt"
          File.open(salt_file, 'w') { |file| file.puts('') }

          result = subject.execute(key)
          expect(result).to eq password

          # retrieve what has been stored by libkv and validate
          stored_info = call_function('libkv::get', "gen_passwd/#{key}")
          expect(stored_info['value']['password']).to eq password
          expect(stored_info['value']['salt']).to_not be_empty

          expect( File.exist?(password_file) ).to be false
          expect( File.exist?(salt_file) ).to be false

          archive_password_file = password_file.gsub('gen_passwd', '.gen_passwd')
          expect( File.exist?(archive_password_file) ).to be true
          archive_salt_file = salt_file.gsub('gen_passwd', '.gen_passwd')
          expect( File.exist?(archive_salt_file) ).to be true
        end

        it 'should generate salt for current password when existing salt is missing' do
          # populate old keydir with current password file for the key
          subject()
          vardir = Puppet[:vardir]
          old_keydir =  File.join(vardir, 'simp', 'environments', 'rp_env',
            'simp_autofiles', 'gen_passwd')
          FileUtils.mkdir_p(old_keydir)
          password_file = File.join(old_keydir, key)
          File.open(password_file, 'w') { |file| file.puts(password) }

          result = subject.execute(key)
          expect(result).to eq password

          # retrieve what has been stored by libkv and validate
          stored_info = call_function('libkv::get', "gen_passwd/#{key}")
          expect(stored_info['value']['password']).to eq password
          expect(stored_info['value']['salt']).to_not be_empty

          expect( File.exist?(password_file) ).to be false

          archive_password_file = password_file.gsub('gen_passwd', '.gen_passwd')
          expect( File.exist?(archive_password_file) ).to be true
        end

        it 'should generate salt for last password when existing salt is empty' do
          # populate old keydir with last password and salt files for the key
          subject()
          vardir = Puppet[:vardir]
          old_keydir =  File.join(vardir, 'simp', 'environments', 'rp_env',
            'simp_autofiles', 'gen_passwd')
          FileUtils.mkdir_p(old_keydir)
          last_password_file = File.join(old_keydir, "#{key}.last")
          File.open(last_password_file, 'w') { |file| file.puts(password) }
          last_salt_file = File.join(old_keydir, "#{key}.salt.last")
          File.open(last_salt_file, 'w') { |file| file.puts('') }

          result = subject.execute(key, {'last' => true})
          expect(result).to eq password

          # retrieve what has been stored by libkv and validate
          stored_info = call_function('libkv::get', "gen_passwd/#{key}.last")
          expect(stored_info['value']['password']).to eq password
          expect(stored_info['value']['salt']).to_not be_empty

          expect( File.exist?(last_password_file) ).to be false
          expect( File.exist?(last_salt_file) ).to be false

          archive_password_file = last_password_file.gsub('gen_passwd', '.gen_passwd')
          expect( File.exist?(archive_password_file) ).to be true
          archive_salt_file = last_salt_file.gsub('gen_passwd', '.gen_passwd')
          expect( File.exist?(archive_salt_file) ).to be true
        end

        it 'should generate salt for last password when existing salt is missing' do
          # populate old keydir with last password file for the key
          subject()
          vardir = Puppet[:vardir]
          old_keydir =  File.join(vardir, 'simp', 'environments', 'rp_env',
            'simp_autofiles', 'gen_passwd')
          FileUtils.mkdir_p(old_keydir)
          last_password_file = File.join(old_keydir, "#{key}.last")
          File.open(last_password_file, 'w') { |file| file.puts(password) }

          result = subject.execute(key, {'last' => true})
          expect(result).to eq password

          # retrieve what has been stored by libkv and validate
          stored_info = call_function('libkv::get', "gen_passwd/#{key}.last")
          expect(stored_info['value']['password']).to eq password
          expect(stored_info['value']['salt']).to_not be_empty

          expect( File.exist?(last_password_file) ).to be false

          archive_password_file = last_password_file.gsub('gen_passwd', '.gen_passwd')
          expect( File.exist?(archive_password_file) ).to be true
        end

        it 'should only archive current salt file without a current password file' do
          # populate old keydir with current salt file for the key
          subject()
          vardir = Puppet[:vardir]
          old_keydir =  File.join(vardir, 'simp', 'environments', 'rp_env',
            'simp_autofiles', 'gen_passwd')
          FileUtils.mkdir_p(old_keydir)
          salt_file = File.join(old_keydir, "#{key}.salt")
          File.open(salt_file, 'w') { |file| file.puts(salt) }

          result = subject.execute(key)
          expect(result).to_not eq password

          # retrieve what has been stored by libkv and validate
          stored_info = call_function('libkv::get', "gen_passwd/#{key}")
          expect(stored_info['value']['password']).to_not eq password
          expect(stored_info['value']['salt']).to_not eq salt

          expect( File.exist?(salt_file) ).to be false

          archive_salt_file = salt_file.gsub('gen_passwd', '.gen_passwd')
          expect( File.exist?(archive_salt_file) ).to be true
        end

        it 'should only archive last salt file without a last password file' do
          # populate old keydir with last salt file for the key
          subject()
          vardir = Puppet[:vardir]
          old_keydir =  File.join(vardir, 'simp', 'environments', 'rp_env',
            'simp_autofiles', 'gen_passwd')
          FileUtils.mkdir_p(old_keydir)
          last_salt_file = File.join(old_keydir, "#{key}.salt.last")
          File.open(last_salt_file, 'w') { |file| file.puts(salt) }

          result = subject.execute(key, {'last' => true})
          expect(result).to_not eq password

          # retrieve what has been stored by libkv and validate
          stored_info = call_function('libkv::get', "gen_passwd/#{key}.last")
          expect(stored_info['value']['password']).to_not eq password
          expect(stored_info['value']['salt']).to_not eq salt

          expect( File.exist?(last_salt_file) ).to be false

          archive_salt_file = last_salt_file.gsub('gen_passwd', '.gen_passwd')
          expect( File.exist?(archive_salt_file) ).to be true
        end

        it 'should fail migration when lock cannot be obtained' do
          # populate old keydir with current password and salt files for the key
          subject()
          vardir = Puppet[:vardir]
          old_keydir =  File.join(vardir, 'simp', 'environments', 'rp_env',
            'simp_autofiles', 'gen_passwd')
          FileUtils.mkdir_p(old_keydir)
          password_file = File.join(old_keydir, key)
          File.open(password_file, 'w') { |file| file.puts(password) }
          salt_file =  "#{password_file}.salt"
          File.open(salt_file, 'w') { |file| file.puts(salt) }

          lockfile = File.join(old_keydir, '.migrate')

          locked_operation(lockfile) do
            puts "     >> Executing simplib::passgen with migration for '#{key}'"
            expect { subject.execute(key, {'gen_timeout_seconds' => 1}) }.
              to raise_error(RuntimeError, /simplib::passgen timed out for '#{key}'/)
          end

          expect(call_function('libkv::exists', "gen_passwd/#{key}")).to be false

          expect( File.exist?(password_file) ).to be true
          expect( File.exist?(salt_file) ).to be true
          archive_password_file = password_file.gsub('gen_passwd', '.gen_passwd')
          expect( File.exist?(archive_password_file) ).to be false
          archive_salt_file = salt_file.gsub('gen_passwd', '.gen_passwd')
          expect( File.exist?(archive_salt_file) ).to be false
        end
      end

      context 'misc errors' do

        it 'fails when password generation times out' do
          Timeout.expects(:timeout).with(30).raises(Timeout::Error, "Timeout")
          is_expected.to run.with_params('spectest').and_raise_error(RuntimeError,
            /simplib::passgen timed out for 'spectest'!/)
        end

        it 'fails when libkv operation fails' do
          libkv_options = {
            'backend'  => 'oops',
            'backends' => {
              'oops'  => {
                'type' => 'does_not_exist_type',
                'id'   => 'test',
              }
            }
          }

          is_expected.to run.with_params('spectest', {}, libkv_options).
            and_raise_error(ArgumentError,
            /libkv Configuration Error/)
        end
      end


      context 'with password_options parameter errors' do
        it do
          is_expected.to run.with_params('spectest', {'length' => 'oops'}).and_raise_error(
            /Error: Length 'oops' must be an integer/)
        end

        it do
          is_expected.to run.with_params('spectest', {'complexity' => 'oops'}).and_raise_error(
            /Error: Complexity 'oops' must be an integer/)
        end

        it do
          is_expected.to run.with_params('spectest', {'hash' => 'sha1'}).and_raise_error(
            /Error: 'sha1' is not a valid hash/)
        end
      end
    end
  end
end
